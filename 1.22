import json
import numpy as np
import onnxruntime as ort
import piper_phonemize

class PiperPreprocessor:
    def __init__(self, config_path):
        with open(config_path, 'r', encoding='utf-8') as f:
            self.config = json.load(f)
        
        self.phoneme_id_map = self.config['phoneme_id_map']
        self.espeak_voice = self.config['espeak']['voice']
        
        # 获取特殊 Token ID
        # Piper 中 Pad 默认为 '_', ID 通常是 0
        self.pad_id = self.phoneme_id_map.get('_', [0])[0]
        self.bos_id = self.phoneme_id_map.get('^', [1])[0]
        self.eos_id = self.phoneme_id_map.get('$', [2])[0]

    def intersperse(self, lst, item):
        """
        在列表的每个元素中间插入 item (Pad ID)
        例如: [1, 2, 3] -> [1, 0, 2, 0, 3]
        """
        if not lst:
            return []
        result = [item] * (len(lst) * 2 - 1)
        result[0::2] = lst
        return result

    def text_to_ids(self, text, use_intersperse=True):
        """将文本转换为音素 ID 列表，并根据需要插入 Pad"""
        # 1. 文本转音素
        phonemes_list = piper_phonemize.phonemize_espeak(
            text, self.espeak_voice
        )
        
        phonemes = []
        for p in phonemes_list:
            phonemes.extend(p)

        # 2. 音素转 ID
        # 注意：先转 ID 列表，再处理 BOS/EOS 和 Pad
        phoneme_ids = []
        for phoneme in phonemes:
            if phoneme in self.phoneme_id_map:
                phoneme_ids.extend(self.phoneme_id_map[phoneme])
            else:
                print(f"Warning: Skipping unknown phoneme '{phoneme}'")
        
        # 3. 插入 Pad (Intersperse)
        # 这一步非常关键：通常是在 BOS 和 EOS 之间插入带 Pad 的序列
        if use_intersperse:
            phoneme_ids = self.intersperse(phoneme_ids, self.pad_id)

        # 4. 构建最终序列： BOS + [Pads...] + EOS
        sequence = [self.bos_id] + phoneme_ids + [self.eos_id]
        
        return sequence

    def prepare_tensor(self, text, speaker_id=0):
        sequence = self.text_to_ids(text, use_intersperse=True)
        
        input_tensor = np.array([sequence], dtype=np.int64)
        input_lengths = np.array([len(sequence)], dtype=np.int64)
        
        # Scales: noise, length(语速), noise_w
        scales = np.array([0.667, 1.0, 0.8], dtype=np.float32)

        inputs = {
            "input": input_tensor,
            "input_lengths": input_lengths,
            "scales": scales
        }
        
        if self.config.get('num_speakers', 1) > 1:
            inputs["sid"] = np.array([speaker_id], dtype=np.int64)
            
        return inputs

# --- 测试部分 ---
if __name__ == "__main__":
    # 替换你的模型路径
    model_path = "en_US-lessac-medium.onnx"
    config_path = "en_US-lessac-medium.onnx.json"
    
    text = "Piper is awesome"
    
    try:
        preprocessor = PiperPreprocessor(config_path)
        tensor_inputs = preprocessor.prepare_tensor(text)
        
        print(f"生成的 ID 序列: {tensor_inputs['input'][0]}")
        print(f"序列长度: {tensor_inputs['input_lengths']}")
        
        # 验证 Pad 是否插入成功 (假设 Pad ID 为 0)
        ids = tensor_inputs['input'][0]
        # 跳过 BOS(首) 和 EOS(尾)，检查中间是否隔一个就是一个 0
        is_interspersed = all(x == 0 for x in ids[2:-1:2])
        print(f"Pad (ID=0) 插入检查: {'成功' if is_interspersed else '失败'}")

    except Exception as e:
        print(f"Error: {e}")
