DRM Lease（租赁）机制概述

工作原理： DRM 租赁允许一个 DRM 主控（Lessor，通常由打开 /dev/dri/cardX 的进程得到）创建新的 DRM 主控（Lessee），并将部分显示资源独占地“租赁”给后者。被租赁的资源（如连接器、CRTC、平面等）在租赁期间只能被 Lessee 控制，原始 Lessor 除非取消租赁或 Lessee 关闭，否则无法再使用这些资源。内核通过新的 IOCTL 接口实现租赁：drmModeCreateLease(fd, objects, num_objects, flags, &lessee_id) 会返回一个新的 DRM 文件描述符，该描述符即持有租赁合同、控制所列资源的 Lessee。之后可通过 drmModeChangeLease 更新租赁内容，或调用释放接口结束租赁。典型的用户空间实现（如“租赁管理”守护进程）会打开 DRM 设备，按需为每个客户端创建 Lessee，并将对应的文件描述符通过 Unix 域套接字传递给客户端。客户端接收到后即可直接对接管的显示硬件进行模式设置和绘制，完成后由管理进程收回租赁。总之，DRM 租赁本质上是**多 DRM 主控（多会话）**机制，使不同进程可独立控制互不重叠的显示资源。

目标与设计动机： DRM 租赁最初为虚拟现实（VR）和类似场景设计，目的是让 VR 应用绕开桌面合成器，直接驱动显示以降低延迟。其主要目标包括：第一，允许 VR 程序直接使用 KMS 接口来驱动头戴显示器（HMD）的显示，获得更低的时延和更高性能；第二，将 HMD 等专用显示设备从桌面系统“隐藏”，避免桌面重新配置或窗口弹出干扰 VR 体验；第三，实现多用户/多会话或嵌入式系统下的资源隔离，例如在汽车仪表+中控双屏场景中，将仪表盘和信息娱乐界面分别租赁给不同容器进程以独立渲染。总之，租赁机制的设计动机是细粒度地划分 GPU/显示硬件资源：使多个应用或会话可以同时安全独占地使用不同的显示输出，而无需完全切换主控权或重启显卡驱动。

典型应用场景：

虚拟现实（VR）：SteamVR、OpenXR 等 Linux VR 平台均依赖 DRM 租赁进行「直通模式」。VR 应用（如 SteamVR、Monado）获取头显的独占控制权后，直接对 HMD 显示器进行模式设置和提交帧，大幅减少了经桌面合成器的复制与同步开销。正如 Drew DeVault 所述，Wayland 合成器（作为 DRM 主控）可将显示资源租赁给客户端，让 VR 应用直接驱动显示器以减少延迟。

多会话/多用户（Multi-seat）：在同一 GPU 上运行多个独立会话时，租赁可将不同物理接口（HDMI、DP 等）划分给不同的用户或虚拟终端。例如有提议让 systemd-logind 持有主 DRM 设备，然后将两个接口分别租赁给 seat0 和 seat1，从而实现在一张显卡上多人的独立桌面。

专用显示与信息亭（Kiosk/嵌入式）：在信息亭、广告屏或汽车中控等场景下，专用应用可能需要完全控制某块屏幕。借助 DRM 租赁，这些应用可以获得相应输出的独占权限，无需关注桌面环境的窗口管理逻辑，简化系统切换。汽车领域已有项目（AGL）使用“租赁管理器”按需为不同客户端创建 DRM 主控，客户端直接渲染后由管理器回收。

远程显示/虚拟化：虽然传统远程桌面多使用帧缓存转发，但 DRM 租赁也可用于 GPU 虚拟化和资源分区，例如将物理 GPU 划给虚拟机或远程会话。已有提议利用租赁将同一 KMS 设备拆分给不同的虚拟桌面，实现更高效的 GPU 资源共享。


X11 与 Wayland 中的支持与实现差异： 在 Wayland 框架下，已有专门的协议和实现支持 DRM 租赁。Wayland-Protocols 1.22 于2021年引入了 wp_drm_lease_v1 协议（最初作为试验特性），允许合成器（DRM Master）向客户端暴露租赁功能。多种 Wayland 合成器（如 wlroots/Sway、KWin/Mutter）都在陆续加入该支持。Wayland 客户端可以通过该协议请求屏幕连接器的独占使用权，从而直接渲染到显示器。此外，为了让 Vulkan 应用使用租赁机制，Drew DeVault 等人还提出了 VK_EXT_acquire_wl_display 扩展，使 Vulkan 程序能在 Wayland 上类似 VK_EXT_acquire_xlib_display（X11）那样获得显示控制权。

在 X11 环境中，DRM 租赁的支持主要通过扩展和兼容层实现。X.Org 曾讨论过向 RandR 增加新请求（如 RRCreateLease）来创建租赁，返回 DRM 文件描述符；相关补丁已经在开发中。值得一提的是，XWayland（运行在 Wayland 之上的 X 服务器）在最近版本（22.1.0）中添加了对 DRM Lease 协议的支持，使得在 Wayland 上运行的 X11 应用同样可以使用 VR 租赁功能。总结而言，Wayland 原生具备专门的租赁协议和逐渐完善的实现，而 X11 则需要借助 RandR 扩展或 XWayland 等方案来兼容这一机制。

驱动与硬件支持情况： 目前主流开源 DRM 驱动（如 Intel i915、AMDGPU、开源 NVIDIA (nouveau) 及其他符合 DRM 规范的显示驱动）都已支持 DRM 租赁机制，用户空间可通过 libdrm 的接口进行调用。不过，NVIDIA 的闭源专有驱动对 DRM 直通功能的支持有限。开发者论坛指出，在 2025 年前所有已知的 NVIDIA 专有驱动版本均无法成功获取 DRM 租赁；只有其开源模块（NVIDIA 开源驱动）才可能生效。总体来说，只要是采用 Linux 内核原生 DRM/KMS 的显卡驱动，都可以使用租赁；而不支持标准 DRM 接口的专有驱动则无法使用。

相关项目与协议： 除了上文提到的 Wayland 与 RandR 扩展，DRM 租赁也被诸多图形 API 和 VR 框架所使用。例如 Vulkan 提供了 VK_EXT_acquire_xlib_display（X11）和正在开发中的 VK_EXT_acquire_wl_display（Wayland）扩展，允许应用获取显示设备的独占访问权。在 VR 领域，Valve 的 SteamVR 以及其他 OpenXR 运行时（如 Monado）都要求 DRM 租赁才能驱动 HMD 显示，许多开发都是由 Valve、红帽、Intel、NVIDIA 等公司联合推进的。此外，嵌入式与汽车级系统的显示服务器（如 Weston）也有类似的直接显示（Direct Display）功能，与 DRM 租赁理念相近，用于在系统启动阶段或专用界面中对接租赁资源。

参考资料： 以上内容依据最新文档与开发者博客整理。文中保留了核心术语与实现细节的英文原文链接，供深入研究参考。

单屏多进程显示输出的 DRM/KMS 方案分析

DRM租赁机制 (Lease)： DRM 中的 租赁机制允许一个 DRM 主（Lessorr）将自己的显示资源（如连接器、CRTC、平面等对象）“租给”另一个进程（承租者，Lessee）使用。但租赁资源是互斥的：内核文档明确指出不能将同一个对象租给两个承租者。也就是说，如果只有一个 HDMI 连接器和对应的 CRTC，可供租赁给某个进程使用时，该连接器就被认为已“被租出”，其他进程无法再使用该连接器（对它进行任何模式设置或翻页操作）。实际上，为了创建一个租赁，IOCTL 要求至少要指定一个连接器、一个 CRTC 和（若开启全平面支持）一个平面。如果只有一块屏幕，则租赁通常会一次性将整个显示流水线（连接器、CRTC、主平面、覆层平面等）租给承租者。例如，WLRoots/Wayland 的示例代码会枚举连接器、CRTC、主平面、游标平面和所有覆盖平面，将它们一起包含在租赁中。由此可见，租赁本质上是独占性的：同一连接器及其附属平面一次只能归属于一个承租者/进程。因此，对于只有一个物理显示器的场景，无法通过 DRM lease 同时让两个进程各自部分地控制同一个连接器；否则会违反“同一对象不能被多方承租”的约束。

平面分配与原子提交 (Atomic Commit)： 即使不使用租赁，DRM/KMS 也支持多平面（overlay）叠加的显示方式。在单显示器系统中，一个 CRTC（扫描控制器）可以挂载多个平面，如主平面和若干叠加平面。理论上可以让进程 A 渲染一个平面（例如覆盖屏幕上半部），进程 B 渲染另一个平面（下半部），然后通过一次原子提交将两者组合输出。但关键问题在于谁来提交（commit）状态。Linux DRM 的模式设置接口（无论是 legacy 的 drmModeSetPlane/drmModePageFlip，还是 atomic 的 drmModeAtomicCommit）都要求调用者必须是当前 DRM 主（DRM Master）或者拥有相应权限。正如一位内核开发者所解释的，DRM_IOCTL_MODE_PAGE_FLIP 必须由持有 DRM_MASTER 权限的进程调用。这意味着在普通情况下，只有一个进程可以作为主控反复进行翻屏。如果要让两个独立进程轮流控制显示，一种笨拙的方法是：每次更新时调用 drmSetMaster 将主控切换到当前进程，提交后再 drmDropMaster 交还。虽然这种方法理论上可行，但需要两个进程都具备足够的权限（如 root），并且在切换主控时显示很可能会短暂闪烁。这种跨进程抢占主控并不断切换的方式实现复杂，体验不佳。

在单进程场景下，通过原子提交可以在一次操作中同时更新多个平面状态（例如设置每个平面的帧缓冲、位置、裁剪等），从而实现屏幕划分显示。但是这里还是要由一个进程同时知晓并提交所有平面的设置。如果两个进程都独立提交不同平面，将导致后提交覆盖先提交，除非仔细使用原子提交的布局保持其它平面不变（但那也需要共享内存同步）。一般来说，要让进程 A 和 B 协同输出，常见做法是由一个主进程负责提交，而另一进程仅负责渲染图像到共享缓冲区。具体地，可以让进程 A 作为 DRM 主，分配两个平面；进程 B 将其渲染结果（通过 DMA-BUF 或 mmap 共享的 dumb buffer）提供给进程 A，然后 A 在其提交中将该缓冲区附加到 B 负责的平面上。这样效果上两者看似“同时”控制输出，但实际上只有主进程发出原子提交。这需要进程间的显存/同步信号共享（如 dma-buf 句柄、fence 同步等），通信和同步成本较高。在没有桌面/合成器的纯 KMS 环境下，这种方式必须由应用自行实现缓冲区交换和帧同步逻辑。

其他技术方案： 如果 DRM lease 无法满足需求，可以考虑类似的 KMS 特性和用户态手段：

多平面静态划分： 利用 GPU/驱动提供的叠加平面功能，一个进程（仍需作为 DRM 主）预先创建并启用所需的平面（比如两个覆盖平面，一个显示上半屏内容，一个显示下半屏内容）。其他进程只需将各自画面写入不同的帧缓冲，再通过共享机制（DMA-BUF、mmap dumb buffer）交给主进程使用。这种做法需要主进程持续管理所有平面，并且处理内存带宽、层叠冲突等问题。

原子部分更新 (FB_DAMAGE_CLIPS)： Linux DRM atomic 模式支持 FB_DAMAGE_CLIPS 等属性，只更新帧缓冲的部分区域。但这仍然需要主进程调用 atomic commit，并且硬件/驱动要支持多平面原子更新。两进程并发更新同一 CRTC 的不同区域在现有接口下没有直接机制。

Render Nodes / 退出主控： 理论上，渲染应用可以使用 render-node（仅限渲染命令，无模式设置权限）输出图像，另一进程负责模式设置和扫描。但 render-node 无法执行模式设置或提交，只能进行 GPU 渲染，仍需有人接管提交。即便主进程在完成模式设定后放弃成为 DRM 主，继续调用翻屏等操作也是受限的（正如 StackOverflow 提到，放弃主控后就不能翻页）。

租赁管理器 (drm-lease-manager)： 借鉴工业级方案（如 AGL 的 drm-lease-manager），可以在没有 Wayland/X11 的情况下运行一个守护进程，按配置将不同的连接器分配给不同进程。不过这仍然假设有多个物理连接器可分割使用。对于单个连接器，租赁管理器只能将该连接器整体租给一个进程，不能拆分成多路。其客户端 API 示例（dlm_get_lease("card0-HDMI-A-1") 等）展示了如何获取一个完整连接器的独占控制权，而非屏幕分块。

合成器回退方案： 如果允许使用轻量级合成器（虽然题目禁止 Wayland/X11），可以借助 Weston 等直接输出扩展（Weston direct display）或 wlroots 层的方法，让多个客户端合成到一个输出上。但纯 DRM/KMS 环境中没有现成的“合成器”，必须程序化地完成上面的缓冲交换和层叠。


限制与挑战： 总体上，Linux DRM/KMS 目前不直接支持“同一屏幕上两个 DRM Master 同时各驱动一部分”的模式。一个重要原因是模式设置接口需要 DRM 主控权限；而 DRM lease 的设计又不允许同一资源被多份租赁。换句话说，要么把整个屏幕租给一个进程，要么就让一个进程当主控，让其他进程通过共享缓冲合作输出。实现过程中需要注意：开发者必须深入理解 DRM 对象（连接器、CRTC、平面）的关系，正确使用原子提交；还要处理好进程同步（防止竞态写入同一屏幕区域）、渲染同步（保证画面时序一致、无撕裂）等问题。此外，物理硬件也会限制可用平面数、频带宽度等。例如 Raspberry Pi 的 DRM 驱动最多只有一个主平面加多个覆盖平面，但同一时间全部取满可能会性能不足。综上所述，单连接器场景下实现“多路显示”需要绕过 DRM 主控限制（如手动切换、辅助管理器或共享内存技巧），开发复杂度较高，实际应用要评估系统架构和硬件能力是否足够支撑。

参考示例与资料： 有项目在多显示或 VR 领域使用 DRM lease 进行输出分配（如 wlroots/sway 的租赁管理器、AGL 的 drm-lease-manager 等），但这些都集中在不同输出之间划分资源。如开发者讨论指出“需要一个进程成为 DRM 主，否则不能在另一个进程创建叠加层”；又或示例代码表明，租赁通常连同连接器、CRTC 及所有关联平面一起给出。StackOverflow 上的实践也指出，只能通过频繁 drmSetMaster/drmDropMaster 来让第二个进程在拥有主控时翻页，否则 IOCTL 会被拒绝。综合来看，若要在单屏上让两个独立进程并行“控制”显示，只能依赖单主控+多缓冲区交互的方案，而不是 DRM lease 本身。

结论： 目前内核的 DRM/KMS 框架并不原生支持在只有一个连接器的情况下让两个独立进程各自驱动屏幕的一部分（即真正的多路输出）。使用 DRM lease 只能独占整个输出端口，无法共享给多方；其他方式则需以一个进程为主控，利用多个平面和缓冲区交换来达到类似效果。实现难度较大，需综合考虑内核接口限制、驱动能力和开发同步复杂度。



